---
layout: post
title: 数据的表示
date: 2012-12-10 22:43
comments: true
categories: Program
---

## 简介

这是对《深入理解操作系统》中的第二章信息的表示和处理的一篇总结。

>孤立地讲，单个的位不是非常有用。然而，当把位组合在一起，再加上某种解释(interpretation)，即给不同的可能位模式赋予含义，我们就能够表示任何有限集合的元素。

>我们研究三种最重要的数字表示。**无符号数**编码基于传统的二进制表示法，表示大于或者等于零的数字。**补码**编码是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。**浮点数**编码是表示实数的科学记述法的以二为基数的版本。

<!-- more -->

## 引言

### 大小端

最低有效字节在最前面的方式，成为**小端法**；最高有效字节在最前面的方式，称为**大端法**，大多数Intel兼容机都采用后一种方式。

字节顺序会成为问题的情形有以下两种：

1. 在不同类型的机器之间通过网络传送二进制数据时

2. 当阅读表示整数数据的字节序列时，字节顺序也很重要

### 位级运算

C语言的一个很有用的特性就是它支持按位布尔运算。

确定一个位级表达式的结果最好的方法，就是将十六进制的参数扩展成二进制表示并执行二进制运算，然后再转换回十六进制。

位级运算的一个常见用法就是实现**掩码**运算，这里掩码是一个位模式，表示一个从一个字中选出的位的集合。

例如，`x=0x89ABCDEF,x&0xFF=0x000000EF`

### 逻辑运算

逻辑运算与位级运算的区别：

1. 逻辑运输认为所有非零的参数都表示`TRUE`，而参数0表示`FALSE`。

2. 逻辑运算符`&&`和`||`与它们对应的位级运算`&`和`|`的重要区别是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。

### 移位运算

C表达式`x<<k`，x向左移动k位，丢弃最高的k位，并在右端补k个`0`。移位运算是从左至右可结合的，所以`x<<j<<k`等价于`(x<<j)<<k`。

一般而言，机器支持两种形式的右移：逻辑右移和算术右移。逻辑右移在左端补k个0，算术右移是在左端补k个最高有效位的值。

C语言对于无符号数据，右移必须是逻辑的。而对于有符号数据，算术的或者逻辑的右移都可以。然而，实际上，几乎所有的编译器/机器组合都对有符号数据使用算数右移。

## 整数表示

### 无符号数的编码

$$B2U_{w}(\overrightarrow{x})\doteq \sum_{i=0}^{w-1}x_{i}2^{i}$$

![Unsigned](/images/unsigned.png)
例子：

$$B2U_{4}([1011])=1\cdot 2^{3}+0\cdot 2^{2}+1\cdot 2^{1}+1\cdot 2^{0}=8+0+4+2=11$$

无符号数的二进制表示有一个很重要的属性，就是每个介于0~$$2_{w}-1$$之间的数都有唯一一个w位的值编码(双射)。

### 补码编码

在补码的定义中，将字的最高有效位解释为**负权**(negative weight)。

$$B2T_{w}(\overrightarrow{x})\doteq -x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_{i}2^{i}$$

![two's-complement](/images/two.png)

例子：

$$B2T_{4}([1011])=-1\cdot 2^{3}+0\cdot 2^{2}+1\cdot 2^{1}+1\cdot 2^{0}=-8+0+2+1=-5$$

w位补码所能表示的值的范围：

最小值是位向量`[10...0]`,其整数值为$$TMin_{w}\doteq -2^{w-1}$$

最大值是位向量`[01...1]`，其整数值为$$TMax_{w}\doteq \sum_{i=0}^{w-2}2^{i}=2^{w-1}-1$$

可以看出$$B2T_{w}$$是一个从长度w的位模式到$$TMin_{w}$$和$$TMax_{w}$$之间的数字的映射(双射)。

补码的两个特点：

1. 补码的范围是不对称的：

   $$ \left | TMin \right | = \left | TMax \right |+1$$

2. 最大的无符号数值刚好比补码的最大值的两倍大一点：$$UMax_{w}=2TMax_{w}+1$$。

注：C语言标准并没有要求用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的。

### 有符号数和无符号数之间的转换

强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。

对大多数C语言的实现而言，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。

现将$$U2B_{w}$$定义为$$B2U_{w}^{-1}$$，而将$$T2B_{w}$$定义为$$B2T_{w}^{-1}$$。

将函数$$U2T_{w}$$定义为$$U2T_{w}(x)\doteq B2T_{w}(U2B_{w}(x))$$，将函数$$T2U_{w}$$定义为$$T2U_{w}\doteq B2U_{w}(T2B_{w}(x))$$。

例子：

![numbers](/images/num.png)

$$T2U_{16}(-12345)=53191$$

$$U2T_{16}(53191)=-12345$$

即十六进制表示写作`0xCFC7`的16位位模式既是`-12345`的补码表示，又是`53191`的无符号数表示。

![num](/images/convert1.png)

若令$$\overrightarrow{x} = T2B_{w}$$，即可得到以下公式：

$$
B2U_{w}(T2B_{w})) = T2U_{w}(x) = x_{w-1}2^{w} + x
$$

$$
T2U_{w}(x)=\left\{\begin{matrix}
x+2^{w} &x<0 \\ 
x & x\geq 0
\end{matrix}\right.
$$

![T2U](./images/convert2.png)

若令$$\overrightarrow{u} = U2B_{w}(u)$$，即可得到以下公式：

$$
B2T_{w}(U2B_{w}(u)) = U2T_{w}(u) = -u_{w-1}2^{w}+u
$$

$$
U2T_{w}(x)=\left\{\begin{matrix}
u & x<2^{w-1} \\ 
u-2^{w} & x\geq2^{w-1}
\end{matrix}\right.
$$

![U2T](./images/convert3.png)

对于在$$0\leq x < 2^{w-1}$$范围之内的值x而言，我们得到$$T2U_{w}(x) = x$$和$$U2T_{w}(x) = x$$。也就是说，在这个范围内的数字有相同的无符号和补码表示。对于这个范围以外的数值，转换需要加上或者减去$$2^{w}$$。

To be continued...
